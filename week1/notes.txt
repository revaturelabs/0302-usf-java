Week 1 notes:

Collection vs Collections Framework vs java.util.Collections:
Collection is the interface that is the root of the Collections Framework.
Collections Framework is a feature in java.util that provides commonly used data structures
java.util.Collections is a utility class for working with objects that implement Collection


Exceptions: Exceptions exist to notify developers of and allow them to handle "exceptional behaviour".
- behaviour that is outside of our intended behaviour, or state that is outside of our intended state can cause Exceptions
- Exceptions only occur when something is going wrong, but we're happy to have them as developers because they help us handle
	those problems.
- Exceptions are Java objects, specifically java.lang.Exception
- When an Exception occurs, we say that the Exception was *thrown*.
- When an Exception is dealt with and the problem resolved, we say that the Exception was *handled*
- The first step to handling an Exception is to *catch* that Exception.
- When we want to cause an Exception to occur, we *throw* it.

As developers, we need to make use of both halves of the above behaviour.  We will catch and handle Exceptions in our code
and we'll throw Exceptions when something goes wrong.

An unhandled Exception will crash your program.
A handled Exception allows the program to continue.

Related Java keywords:
"throw" will let you throw an Exception.
"try", "catch", and "finally" allow you to handle Exceptions.
"throws" specifies that an Exception won't be handled by a given method. (we'll see this tomorrow)

We'll use the throw keyword to throw an Exception when a problem has occurred in our code
We'll use try-catch-finally to handle an Exception thrown elsewhere in our code
We'll use throws to "pass the buck" and not handle an Exception in a given method.


Scanner (quick):
A Scanner is a convenience object in Java that enables console input.
We use a scanner to take input from the user of our application.
We typically switch on the user input to let the user choose application functionality.


Exceptions vs. Errors:
java.lang.Exception and java.lang.Error are both subclasses of a class called java.lang.Throwable.
Any object that is Throwable works with the "throws", "try", "catch", "throw", "finally" keywords.
java.lang.Exception works with these keywords only because it is Throwable.  java.lang.Error is the same way.
The big difference between Exceptions and Errors is how we are expected to handle them.
An Exception we should attempt to recover from -- we use try-catch to catch the Exception then
write appropriate logic to handle it in our catch blocks.
An Error, on the other hand, can almost never be fixed and we ought just let the program crash.
Most Errors have to do with problems with the JVM like java.lang.StackOverflowError (out of space on the stack)
and java.lang.OutOfMemoryError (out of space on the heap).


What is RuntimeException?
We've been using RuntimeException instead of Exception.  The reason is that RuntimeException and its child
classes are *unchecked Exceptions*. This is in contrast to Exception (and all non-RuntimeExceptions), which
 are *checked exceptions*.  Unchecked vs checked refers to whether the compiler enforces that you handle
a given Exception.  Unchecked vs checked refers the *the compiler* checking whether you have Exception
handling logic.

In Java, we're expected to handle any Exception we can anticipate.  It's good practice.  Some Exceptions 
the compiler can anticipate.  It forces us to write code to handle those exceptions before it will compile.
Those are checked Exceptions.
Some other Exceptions are difficult for the compiler to anticipate.  In these cases, its good practice to
write code to handle those Exceptions, but the compiler can't force us to do it.

Example checked Exceptions:
FileNotFoundException when working with files
SQLException when reading/writing to a database
^ The compiler knows that these might occur every time we try to work with files or with databases,
so these are checked Exceptions.

Example unchecked Exceptions:
ArrayIndexOutOfBoundsException
ClassCastException
ArithmeticException
^ These exceptions might or might not occur any time we're working with Arrays, casting, or division,
so these are unchecked exceptions -- the compiler doesn't know where they might happen.



Wednesday:

More Maven: Maven is a build automation and dependency management tool.
Builds in Maven are automated and split into a series of steps called the Maven build lifecycle.
We'll use the default maven build lifecycle, but know that it is customizable.
It can produce test reports, build your project as a "docker image" (don't worry about what this means just yet),
run multiple testing steps, build for multiple environments, ... plugins enable almost any build functionality you need.
The default build lifecycle is 7 steps.  We should focus on the first 4:
1: validate -- checks the POM and the project directory to ensure Maven project is valid and can be built
2: compile -- compiles your .java code into bytecode to be run.
3: test -- runs any JUnit tests in src/test/java.  This will provide a printout with successes/failures on the console.
4: package -- takes all of your compiled java files and places them in a single archive file, most commonly a .jar file.
	.jar files are java archives and they provide an easy way to share, move, deploy your completed java project.
	We call files like .jar files produced from a build "artifacts".
5: verify -- ensure package was produced correctly
6: install -- add package to local maven repository
7: deploy -- add package to central maven repository
All of the dependencies we get using Maven were built using this lifecycle and it's the deploy step that makes them available to us.

Maven repository: a location that Maven uses to store packaged dependencies.  There is a local repo on our machine, and 
a central repo on mvnrepository.com.  For any dependencies we include in our projects, maven first checks the local repo,
then downloads from the central repo to the local repo if necessary.  Any .jar files (packages, dependencies) in our local repo
are available to our Maven projects.  We just need to add the <dependency>...</dependency> tag.

few more topics: where is local maven repo, what is XML, what is a tag, and how to actually run maven commands...




